# CommandLine Parser

CommandLine Parser can be used for parsing command line as well as generate usage information automatically.

It stores options and values into a map.

It's easy to check whether an option exist, and get value with a specified type.

# Usage

`CommandLine Parser` includes two parts,

* parser (commandline_parser.cc)
* usage generator (usage_generator.cc)

both part can be simply used as follows:

### parser

1. Include the header 'commandline_parser.h'.
2. Declare an object associate with CParser.
3. Call CParser::parse() manually.
4. Verify an option by calling has(),has_or(),has_and().
5. To get a value from specified option by calling get() and then as<T>().

```cpp
// $ path/to/program -xyz 3.14 --option value
CParser parser;
parser.parse(argc, argv);

// to get a value from an option
parser.get("z")->as<double>();
parser.get("option")->val(); // std::string

// verify an option
parser.has("option")

// verify a sequence of options
parser.has_or(2, "x", "y");
parser.has_and(2, "option", "c");
parser.has_and(1, "-xy");
```

For more details and examples, check out `test/parser_test.cc`

### usage generator

1. Include the header 'usage_generator.h'.
2. Declare an object associate with Generator.
3. Begin with `Generator::MakeUsage()`.
4. Then just append parentheses and add your options and descriptions.
5. Finally, just `std::cout << object;` and you will get all usage information.

```cpp
Generator generator;

generator.MakeUsage("Usage for example:")
      ("h,help", "show help information")
      ("o,option", "", "this is an option")
      (",option-2", "this is the option 2")
      ("c,", "this is option c")
      ("p,position", "0.0", "position of a place");

cout << generator;

/*
Usage for example:
  -h [ --help ]               show help information
  -o [ --option ] arg         this is an option
  --option-2                  this is the option 2
  -c                          this is option c
  -p [ --position ] arg = 0.0 position of a place
*/
```

Note: 

* The first parameter's format: `short-form,long-form`, You can set any one of them or both.
* If you don't require a value of an option, you don't need to set the second parameter inside the parentheses, and the **arg** will not be displayed. Otherwise, set it.

# TODOs

At present, the two parts of `CommandLine Parser` are separated, we want to put them together, make use of the default value and the first parameter generated by `usage generator`.

For example:

when both `-o` and `--option` are allowed in command line,

we expect:

```cpp
parser.has("o");
// is the same as
parser.has("option");
```

unfortunately, the `parser` don't know the rules, at present we must:

```cpp
parser.has_or(2, "o", "option");
// or
if (parser.has("o") || parser.has("option"))
  ...
```

 it's unfriendly to users.
