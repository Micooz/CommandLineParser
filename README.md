# CommandLine Parser

CommandLine Parser can be used for parsing command line as well as generate usage information automatically.

It stores options and values into a map.

It's easy to check whether an option exist, and get value with a specified type.

# Usage

`CommandLine Parser` includes two parts,

* parser (commandline_parser.cc)
* usage generator (usage_generator.cc)

both part can be simply used as follows:

### parser

1. Include the header 'commandline_parser.h'.
2. Declare an object associate with CParser.
3. Call CParser::parse() manually.
4. Verify an option by calling has(),has_or(),has_and().
5. To get a value from specified option by calling get() and then as<T>().

```cpp
// $ path/to/program -xyz 3.14 --option value
CParser parser;
parser.parse(argc, argv);

// to get a value from an option
parser.get("z")->as<double>();
parser.get("option")->val(); // std::string

// verify an option
parser.has("option")

// verify a sequence of options
parser.has_or(2, "x", "y");
parser.has_and(2, "option", "c");
parser.has_and(1, "-xy");
```

It also supports "=" to assign a value to an option:

```cpp
// $ path/to/program --option=value1,value2... -c=config.json
parser->get("option")->val(); // value1,value2...
parser->get("c")->as<std::string>(); // config.json
```

For more details and examples, check out `test/parser_test.cc`

### usage generator

1. Include the header 'usage_generator.h'.
2. Declare an object associate with Generator.
3. Begin with `Generator::MakeUsage()`.
4. Then just append parentheses and add your options and descriptions.
5. Finally, just `std::cout << object;` and you will get all usage information.

```cpp
Generator generator;

generator.MakeUsage("Usage for example:")
      ("h,help", "show help information")
      ("o,option", "", "this is an option")
      (",option-2", "this is the option 2")
      ("c,", "this is option c")
      ("p,position", "0.0", "position of a place");

cout << generator;

/*
Usage for example:
  -h [ --help ]               show help information
  -o [ --option ] arg         this is an option
  --option-2                  this is the option 2
  -c                          this is option c
  -p [ --position ] arg = 0.0 position of a place
*/
```

Note: 

* The first parameter's format: `short-form,long-form`, You can set any one of them or both.
* If you don't require a value of an option, you don't need to set the second parameter inside the parentheses, and the **arg** will not be displayed. Otherwise, set it.
* If no comma in the first parameter, this usage row will be ignored.

For more examples, check out `test/generator_test.cc`

### Make a combination

At present, the two parts above can be used together.

Consider the following situation:

As the `usage generator` example shows, assignment of `-o` and `--option` are the same, but we don't know which one is given, how `parser` check it out?

In the previous version,

```cpp
if (parser.has_or(2, "o", "option"))
    // -o or --option was set
// or
if (parser.has("o") || parser.has("option"))
    // -o or --option was set
```

as you see, when we have a lot of option to be checked, it's so wordy and unfriendly.

But now, you can get `parser` through `Generator::MakeParser()`:

```cpp
CParser* parser = generator.MakeParser();
```

then the parser have known the rules generated by generator.

```cpp
if (parser->has("o"))
// or if(parser->has("option"))
// that's enough.
```

Don't worry about the value that any option takes, also ok for taking a value of default value from an option:

```cpp
float position = parser->get("p")->as<float>();
// or 
// float position = parser->get("position")->as<float>();
// as you like.
```

For more examples, check out `test/combination_test.cc`

# TODOs

Nothing to do at the moment. Waiting for your advice.